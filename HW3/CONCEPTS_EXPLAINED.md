# EE217 HW3 - Complete Conceptual Guide

This guide explains all the key concepts you need to understand for this homework, with intuitive examples and practical insights.

---

## PART 1: PRBS (Pseudo-Random Binary Sequences)

### What is a PRBS?

A PRBS is a **deterministic** sequence that looks random but actually repeats after a specific period. Think of it like a really long song on repeat - it seems random when you first hear it, but eventually it loops back to the beginning.

**Key properties:**
- Generated by simple digital logic (Linear Feedback Shift Register)
- Repeats after 2^n - 1 bits (for n-bit LFSR)
- Looks random but is completely predictable
- Has excellent correlation properties

### Why do we care about PRBS?

**Real-world applications:**
1. **Communications:** Spread spectrum systems (GPS, WiFi, cellular)
2. **Testing:** Generate pseudo-random data to test circuits
3. **Synchronization:** Help receivers lock onto signals
4. **Security:** Part of encryption key generation
5. **Touch sensors:** What we're doing in Problem 2!

### How LFSRs Work

An LFSR (Linear Feedback Shift Register) is a shift register with XOR feedback.

**Think of it like a row of light bulbs:**
```
[ðŸ’¡] [ðŸ’¡] [ðŸ’¡] [ðŸ’¡] [ðŸ’¡] [ðŸ’¡] [ðŸ’¡] [ðŸ’¡] [ðŸ’¡]
 b8   b7   b6   b5   b4   b3   b2   b1   b0
```

**Every clock cycle:**
1. Read the rightmost bit (output it)
2. Shift everything right â†’
3. Calculate new leftmost bit by XORing specific positions (determined by polynomial)

**Example for PRBS511 (9-bit, polynomial 0x110):**
- Polynomial 0x110 = 0b100010000
- This means: XOR bit 8 and bit 4
- New bit 8 = old bit 4 âŠ• old bit 8

**Why it works:**
- The polynomial creates a feedback loop
- If chosen correctly (primitive polynomial), it cycles through ALL possible non-zero states
- For 9 bits: 2^9 - 1 = 511 states (we skip all-zeros)

### Galois vs Fibonacci LFSR

There are two architectures:

**Fibonacci (Many-to-One):**
- Multiple taps feed into one XOR
- XOR output goes to the first position
- Like multiple inputs â†’ single feedback

**Galois (One-to-Many):**
- One output bit
- XOR it into multiple positions as you shift
- Simpler to implement in hardware
- This is what we used!

**Galois algorithm:**
```python
output = state & 1           # Get rightmost bit
state = state >> 1           # Shift right
if output == 1:
    state ^= polynomial      # XOR with polynomial
```

### Understanding the Polynomial

The polynomial tells you which bits to use for feedback.

**Example: 0x110 for PRBS511**
- 0x110 = 0b100010000 in binary
- Bit positions 8 and 4 are set
- This represents: x^8 + x^4 + 1
- In math: the sequence satisfies this recurrence relation

**Why these specific polynomials?**
They're "primitive polynomials" - special polynomials that guarantee maximal-length sequences. Number theorists have catalogued which ones work!

---

## PART 2: Correlation

### What is Correlation?

Correlation measures **how similar two signals are** when you slide one past the other.

**Intuitive analogy:**
Imagine you have two songs. Play them at the same time while slowly shifting one forward in time. When they sound most similar, they're highly correlated.

**Mathematical definition:**
```
correlation(shift) = Î£ signal1[i] Ã— signal2[i + shift]
```

For each shift, multiply corresponding samples and sum them up.

### Autocorrelation (Signal vs Itself)

**Autocorrelation:** Correlate a signal with a shifted version of itself.

**Why it matters:**
- Tells you if the signal is periodic
- Shows if the signal is "random-looking"
- Used for synchronization (finding where a pattern starts)

**For PRBS511:**
```
Autocorrelation at shift 0:    +511  (perfect match!)
Autocorrelation at shift â‰  0:  -1    (looks uncorrelated)
```

This is **amazing** because:
- Sharp peak makes it easy to find the pattern
- Low sidelobes mean low interference
- Perfect for synchronization

**Why -1 and not 0?**
When we convert 0/1 to +1/-1 (bipolar), the correlation becomes:
- Same bits: (+1)(+1) = +1 or (-1)(-1) = +1
- Different bits: (+1)(-1) = -1 or (-1)(+1) = -1

For PRBS511:
- 256 ones, 255 zeros
- When shifted, roughly half match, half don't
- Net result: 256 - 255 = 1... but then we subtract the DC component â†’ -1

### Cross-correlation (Signal A vs Signal B)

**Cross-correlation:** Correlate two different signals.

**For PRBS sequences from different polynomials:**
- They're different bit patterns
- But they share some structure (both are maximal-length)
- Cross-correlation is low but not zero (~45 for our case)

**Why low cross-correlation matters:**
In CDMA systems, you want different users' codes to NOT interfere. Low cross-correlation means signals can coexist.

### The 255-bit Subsequence Question

**The question:** Is a 255-bit chunk of PRBS511 actually a PRBS255?

**Intuition:**
Think of PRBS511 as a long necklace of 511 beads. If you cut out 255 beads, do they form a proper PRBS255 necklace?

**Answer: NO**

**Why not:**
1. **Different feedback structure:** PRBS255 needs an 8-bit LFSR with its own polynomial
2. **Wrong autocorrelation:** A true PRBS255 has perfect autocorrelation properties
3. **Subsequence breaks the pattern:** The feedback loop is broken when you extract a chunk

**The data proves it:**
- True PRBS255 should have off-peak autocorrelation of -1
- Best subsequence has off-peak values up to 27
- That's 28x worse!

**Does it depend on which subsequence?**
YES! Different starting positions give different subsequences with different properties. Some are better than others, but NONE are true PRBS255.

---

## PART 3: CDMA Touch Sensing

### What is CDMA?

**CDMA = Code Division Multiple Access**

**The problem it solves:**
How do you let multiple users share the same frequency band at the same time?

**Traditional solutions:**
- FDMA (Frequency): Give each user a different frequency (like radio stations)
- TDMA (Time): Give each user a different time slot (take turns)

**CDMA solution:**
- Everyone transmits at the same time on the same frequency!
- Each user gets a unique spreading code (like a PRBS)
- Receiver correlates to pull out each user's signal

**Analogy:**
Imagine a loud party where everyone speaks a different language. Even though all the sound waves mix together, you can understand your friend speaking English by "correlating" (listening for English patterns) while the Chinese, Spanish, and French conversations become background noise.

### How Touch Sensing Uses CDMA

**Traditional touch sensor:**
```
Drive 1 â†’ [Capacitor] â†’ Sense (measure)
Drive 2 â†’ [Capacitor] â†’ Sense (measure)
Drive 3 â†’ [Capacitor] â†’ Sense (measure)
... (scan one at a time)
```

This is slow - you have to check each drive line sequentially.

**CDMA touch sensor:**
```
Drive 1 (PRBS511, phase 0Â°)   âŽ«
Drive 2 (PRBS511, phase 72Â°)  âŽ¬â†’ All mixed together â†’ Sense
Drive 3 (PRBS511, phase 144Â°) âŽª
... (all at once!)            âŽ­
```

All drives transmit simultaneously! The sense line receives a mix of all signals.

**How we separate them:**
Correlate the sense signal with each drive's PRBS pattern. The correlation peaks tell you each drive line's contribution!

### The Phase Offsets

Each drive line uses the **same PRBS511 sequence** but **shifted** (phase offset).

**Why this works:**
- PRBS511 autocorrelation with itself: +511 (strong peak)
- PRBS511 autocorrelation with shifted version: -1 (looks different!)

So even though it's the same sequence, different shifts act like different codes.

**In the homework:**
```
Drive 1: PRBS511[0:511]
Drive 2: PRBS511[n:511] + PRBS511[0:n]  (circular shift by n)
Drive 3: PRBS511[m:511] + PRBS511[0:m]  (circular shift by m)
...
```

The correlation finds the peaks at different time offsets, telling us the capacitance for each drive line.

### Finding Touch Location

**Without touch:**
Each drive-sense pair has a baseline capacitance (from the correlation peak).

**With touch:**
The finger changes the capacitance (usually decreases it because your finger absorbs some electric field).

**The key insight:**
The capacitance change is strongest where the finger is touching!

**Gaussian assumption:**
The problem says "assume the finger sensor response is Gaussian in space."

This means the capacitance change follows a bell curve:
```
         No finger
Capacitance
    |         *
    |        * *
    |       *   *
    |      *     *
    |    *         *
    |___*___________*___
        5mm  10mm  15mm  20mm  25mm
             â†‘
          Touch here!
```

**Our result:**
- Biggest decrease at 10mm position (-16.63 units)
- Gaussian fit gives touch location: 10.86 mm
- Width (sigma) tells us the finger "spread": 3.63 mm

### Processing Gain from Correlation

**The noise problem:**
The sense line has Gaussian noise added. How do we detect the signal?

**The magic of correlation:**
When you correlate against a PRBS of length N, you get "processing gain" of âˆšN.

For PRBS511:
- Processing gain = âˆš511 â‰ˆ 22.6
- This means the SNR improves by 22.6x!

**Why this works:**
- Signal: Aligned PRBS correlates to N (all bits add up)
- Noise: Random values average out to ~âˆšN

So SNR improves by N/âˆšN = âˆšN.

**In the homework:**
- Noise after correlation: Ïƒ = 2.19
- Noise before correlation: Ïƒ = 2.19 / âˆš511 â‰ˆ 0.097

This is why CDMA works even in noisy environments!

---

## PART 4: DFT/FFT Fundamentals

### What is the DFT?

**DFT = Discrete Fourier Transform**

**What it does:**
Converts a time-domain signal into frequency-domain representation.

**Intuitive understanding:**
Any signal can be decomposed into a sum of sine waves at different frequencies. The DFT tells you the amplitude and phase of each frequency component.

**Musical analogy:**
- Time domain: The waveform (what you see on an oscilloscope)
- Frequency domain: The musical notes (what frequencies are present)
- DFT is like a spectrum analyzer showing which notes are in the chord

**Mathematical definition:**
```
X[k] = Î£(n=0 to N-1) x[n] Ã— e^(-j2Ï€kn/N)
```

For each frequency bin k, we:
1. Multiply the signal by a complex exponential at that frequency
2. Sum up all the results
3. The sum tells us how much of that frequency is present

### DFT as Correlation

The DFT is actually **correlation with complex exponentials**!

```
X[k] = correlation between x[n] and e^(j2Ï€kn/N)
```

We're checking how similar the signal is to sine/cosine waves at each frequency.

### FFT vs DFT

**FFT = Fast Fourier Transform**

Same result as DFT, but faster algorithm:
- DFT: O(NÂ²) operations
- FFT: O(N log N) operations

For N = 1024:
- DFT: ~1 million operations
- FFT: ~10,000 operations (100x faster!)

**Why FFT requires N = 2^m:**
The algorithm recursively splits the problem in half. Only works cleanly when N is a power of 2.

### The Relationship: Y(k) = H(2Ï€k/N) Â· X(k)

**Setup:**
- Input signal x(n) (periodic with period N)
- Linear system with frequency response H(Ï‰)
- Output signal y(n)

**Key insight:**
The DFT samples the frequency domain at discrete points: Ï‰_k = 2Ï€k/N

**Why the relationship holds:**
1. Periodic input x(n) only has frequencies at Ï‰ = 2Ï€k/N (discrete spectrum)
2. Each frequency component passes through the system
3. System scales each component by H(Ï‰) at that frequency
4. DFT output Y[k] = H(2Ï€k/N) Ã— X[k]

**Practical meaning:**
If you know the system's frequency response H(Ï‰) and the input's DFT X[k], you can immediately compute the output's DFT Y[k] without doing convolution!

---

## PART 5: Sampling and Aliasing

### Time-Domain Sampling (Review)

**Nyquist-Shannon Sampling Theorem:**
To perfectly reconstruct a signal with bandwidth B, you need to sample at rate f_s â‰¥ 2B.

**Why 2B?**
- Highest frequency: B Hz
- Need 2 samples per cycle to uniquely represent it
- Below 2B: Aliasing occurs (high frequencies appear as low frequencies)

**Example:**
- Signal bandwidth: 4 kHz
- Minimum sampling rate: 8 kHz (8000 samples/second)

### Frequency Resolution

**Frequency resolution:** How finely can we distinguish between different frequencies?

**Formula:**
```
Î”f = f_s / N = 1 / T
```

Where:
- f_s = sampling rate
- N = number of samples
- T = record length (time)

**Key insight:** To get better frequency resolution, you need a longer recording!

**In the homework:**
- Want Î”f â‰¤ 50 Hz
- Therefore T â‰¥ 1/50 = 0.02 seconds
- With f_s = 8 kHz: N = 8000 Ã— 0.02 = 160 samples
- Round up to 2^8 = 256 for FFT

### Frequency-Domain Sampling (Problem 3c)

This is the **dual** of time-domain sampling!

**What happens:**
- Time-domain sampling â†’ frequency-domain periodicity
- Frequency-domain sampling â†’ time-domain periodicity

**In Problem 3c:**
1. We have X(Ï‰), the DTFT (continuous in frequency)
2. We sample it at N discrete points: X[k] = X(2Ï€k/N)
3. We take inverse FFT to get time-domain signal

**Result:** The time-domain signal becomes periodic with period N!

### Time-Domain Aliasing

**The signal:** x(n) = 0.8^|n|

This extends infinitely in both directions:
```
... 0.8^3, 0.8^2, 0.8^1, 1, 0.8^1, 0.8^2, 0.8^3, ...
         â†                    â†’
```

**When N=20:**
The IFFT assumes the signal is periodic with period 20:
```
[signal from n=0 to 19] [signal from n=0 to 19] [repeat...]
```

**The problem:**
The true signal hasn't decayed to zero at n=Â±10, so when it wraps:
- Tail from n > 10 adds to n < 0
- Tail from n < -10 adds to n > 10

This is **time-domain aliasing** (also called circular aliasing or time-domain folding).

**When N=100:**
- By n=Â±50, the signal has decayed to nearly zero (0.8^50 â‰ˆ 0)
- Very little wrapping occurs
- Reconstruction is accurate near n=0

**The fundamental rule:**
Just like Nyquist for time sampling, there's a "frequency Nyquist":
- To avoid time-domain aliasing, sample enough frequency points that the time signal decays within one period

**Why this matters:**
In practical applications (spectral analysis, filter design), you need to sample the frequency domain finely enough that the corresponding time-domain signal fits within your assumed period.

---

## PART 6: Connecting Everything Together

### The Big Picture

All three problems share a common theme: **Using signal processing to extract information from noisy, complex signals.**

**Problem 1:** Generate and analyze sequences with good correlation properties
**Problem 2:** Use those sequences to multiplex multiple channels and detect touch
**Problem 3:** Understand sampling (in time and frequency) to avoid aliasing

### Key Techniques You've Learned

1. **Sequence Generation:** LFSRs for creating pseudo-random patterns
2. **Correlation:** Detecting signals in noise, synchronization
3. **Code Division:** Multiple access using orthogonal sequences
4. **Frequency Analysis:** DFT/FFT for spectral decomposition
5. **Sampling Theory:** Nyquist criterion, resolution, aliasing

### Real-World Applications

**Smartphones:**
- Touch screen: Capacitive sensing (like Problem 2)
- GPS: Uses PRBS sequences (Gold codes)
- WiFi/Cellular: CDMA for multiple users

**Test Equipment:**
- Oscilloscopes: FFT for spectrum analysis
- Bit error rate testers: PRBS for testing links

**Communications:**
- Spread spectrum: PRBS for spreading signals
- Synchronization: Correlation for locking onto signals

---

## PART 7: Common Misconceptions

### Misconception 1: "PRBS is random"

**Truth:** It's completely deterministic! "Pseudo-random" means it has statistical properties similar to random sequences, but it repeats and is predictable.

### Misconception 2: "Correlation is just pattern matching"

**Truth:** It's weighted pattern matching with phase sensitivity. The correlation value depends on alignment, not just similarity.

### Misconception 3: "FFT is different from DFT"

**Truth:** FFT computes the exact same result as DFT, just faster. It's an algorithm optimization, not a different transform.

### Misconception 4: "Autocorrelation peak should be 1"

**Truth:** The peak value equals the sequence length (N). The -1 off-peak values come from the bipolar mapping and the balanced structure of PRBS.

### Misconception 5: "Any subsequence of a random sequence is random"

**Truth:** For true random sequences, yes. But PRBS has structure! A subsequence breaks the feedback loop and loses the maximal-length properties.

---

## PART 8: Study Tips and Deeper Understanding

### To really understand PRBS:

1. **Draw it out:** Sketch an LFSR and step through it manually
2. **Code it yourself:** Understanding comes from implementation
3. **Visualize:** Plot the sequences, see the autocorrelation
4. **Compare:** Look at different polynomials, see how they differ

### To really understand correlation:

1. **Try examples:** Correlate simple sequences by hand
2. **Shift animations:** Visualize sliding one signal past another
3. **Noise experiments:** Add noise, see how correlation filters it
4. **Different sequences:** Correlate random vs PRBS vs periodic

### To really understand DFT:

1. **Start simple:** Try N=4 or N=8 by hand
2. **Build intuition:** Think of it as "how much of each frequency"
3. **Compare time and frequency:** Plot both domains
4. **Play with sampling:** See what happens when you violate Nyquist

### To really understand aliasing:

1. **Visual examples:** Look at videos of aliasing (wagon wheels)
2. **Generate aliased signals:** Sample too slowly, see the folding
3. **Frequency domain:** Understand spectral overlap
4. **Time-domain aliasing:** The dual problem (Problem 3c)

---

## PART 9: Going Deeper (Optional Advanced Topics)

### Gold Codes

PRBS511 can be used to generate **Gold codes** - pairs of sequences with even better cross-correlation properties. Used in GPS!

**How:** XOR two PRBS sequences with different polynomials
**Result:** A family of sequences with controlled cross-correlation

### Primitive Polynomials

Not all polynomials give maximal-length sequences. **Primitive polynomials** are special:
- Irreducible (can't be factored)
- Cycle through all 2^n - 1 states
- Number theorists have catalogued them

### Matched Filtering

Correlation is actually **matched filtering** - the optimal filter for detecting a known signal in white Gaussian noise!

**Why it's optimal:** Maximizes SNR at the decision point

### Circular vs Linear Correlation

We used **circular correlation** (wrap around). There's also **linear correlation** (zero-pad).

**Circular:** Assumes periodic signals
**Linear:** Assumes finite signals

### Spectral Leakage

When DFT frequencies don't align with signal frequencies, energy "leaks" into adjacent bins. Windowing helps mitigate this.

---

## Summary: Key Equations

**PRBS Properties:**
- Period: 2^n - 1
- Autocorrelation peak: N
- Off-peak autocorrelation: -1

**Correlation:**
- Autocorr[k] = Î£ x[i] Ã— x[i+k]
- Cross-corr[k] = Î£ x[i] Ã— y[i+k]
- Processing gain: âˆšN

**DFT:**
- X[k] = Î£ x[n] Ã— e^(-j2Ï€kn/N)
- Y[k] = H(2Ï€k/N) Ã— X[k]
- Frequency resolution: Î”f = 1/T

**Sampling:**
- Nyquist rate: f_s â‰¥ 2B
- Time resolution: Î”t = 1/f_s
- Frequency resolution: Î”f = 1/T

---

## Final Thoughts

This homework touched on fundamental concepts that appear everywhere in signal processing:

- **Sequences:** Communications, security, testing
- **Correlation:** Detection, synchronization, filtering
- **CDMA:** Wireless systems, sensing
- **DFT/FFT:** Spectral analysis, filtering, communications
- **Sampling:** A/D conversion, system design

Understanding these concepts deeply will help you in:
- Future signal processing courses
- Communications systems
- Digital system design
- Hardware testing
- Practical engineering

The beauty is how these concepts interconnect - correlation in time domain, multiplication in frequency domain, sampling creating periodicity, PRBS giving perfect autocorrelation, etc.

Keep exploring, experimenting, and connecting the dots!
