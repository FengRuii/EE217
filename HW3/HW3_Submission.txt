EE217 Winter 2026
Homework 3
[Your Name]

================================================================================
PROBLEM 1: PRBS SIGNALING
================================================================================

Part (a) - PRBS Generation (10 points)

I wrote Python code to generate PRBS7, PRBS127, PRBS511, and PRBS1023 sequences using a Galois LFSR implementation. The code uses the generator polynomials from the provided table.

Implementation notes:
- Used Galois LFSR architecture (simpler than Fibonacci)
- For each step: output LSB, shift right, XOR with polynomial if output was 1
- Period is 2^n - 1 for n-bit sequences

Results:
- PRBS7: Generated 127 bits using polynomial 0x60
- PRBS127: Same as PRBS7 (127 bits, polynomial 0x60)
- PRBS511: Generated 511 bits using polynomial 0x110
- PRBS1023: Generated 1023 bits using polynomial 0x240

All sequences verified to have the correct period length.

[See code: hw3_solution.py, lines 14-49]


Part (b) - PRBS511 Autocorrelation (10 points)

Generated the autocorrelation curve for PRBS511 by mapping bits from 0/1 to +1/-1 (bipolar format).

Results:
- Autocorrelation at zero offset: 511 ✓
- Autocorrelation at all other offsets: -1 ✓

This confirms I generated PRBS511 correctly using polynomial 0x110.

[See plot: problem1b_autocorr_prbs511.png]


255-bit Subsequence Analysis:

I tested all possible 255-bit subsequences from the PRBS511 sequence to see if any would be a valid PRBS255.

Answer: No, a 255-bit subsequence of PRBS511 is NOT a true PRBS255 sequence.

Why?
A true PRBS255 would need to be generated by a maximal-length 8-bit LFSR with the proper generator polynomial. Just taking 255 consecutive bits from PRBS511 doesn't give you the same feedback structure, so the autocorrelation properties are different.

Does it depend on which subsequence you choose?
Yes, definitely. I tested all 511 possible starting positions and the autocorrelation properties vary significantly.

Best subsequence found:
- Starting index: 292
- Maximum off-peak autocorrelation: 27 (way worse than the -1 we'd want)

For a true PRBS255, we'd expect the autocorrelation to be 255 at zero offset and -1 everywhere else. The best subsequence I found has off-peak values as high as 27, which proves it's not a proper PRBS255.

[See plot: problem1b_autocorr_255bit.png]


Part (c) - Cross-correlation between different PRBS511 generators (10 points, extra credit)

Generated a second PRBS511 sequence using the alternate polynomial 0x108.

seqA: PRBS511 with polynomial 0x110 (from part a)
seqB: PRBS511 with polynomial 0x108

Are they equal?
No. Even though both generate 511-bit sequences, they're completely different bit patterns.

Cross-correlation results:
- Maximum cross-correlation: 45
- This is much lower than the autocorrelation peak (511), which is good
- The low cross-correlation means these sequences are relatively orthogonal

This property makes them useful for CDMA systems where you need multiple users transmitting simultaneously without too much interference.

[See plot: problem1c_crosscorr.png]


================================================================================
PROBLEM 2: CDMA-BASED TOUCH SENSORS
================================================================================

Part (a) - Correlation Peak Analysis (10 points)

Loaded the sense waveform data (HW3.Pr3.notouch.txt) and correlated it against the PRBS511 sequence to extract the capacitance values for each drive line.

Setup:
- Initial LFSR state: 257 (binary 0b100000001)
- Polynomial: 0x110
- 5 drive lines at different phase offsets

Drive/Sense Capacitance Results (No Touch):

Drive Line 1 (5mm):   Phase offset = 21 samples,   Capacitance = 39.34
Drive Line 2 (10mm):  Phase offset = 151 samples,  Capacitance = 27.12
Drive Line 3 (15mm):  Phase offset = 276 samples,  Capacitance = 33.71
Drive Line 4 (20mm):  Phase offset = 341 samples,  Capacitance = 15.72
Drive Line 5 (25mm):  Phase offset = 432 samples,  Capacitance = 7.17

The peaks are NOT equally spaced (as mentioned in the problem), so I had to search through the correlation output to find all 5 peaks. I identified them by looking for the strongest correlation values and verified there were exactly 5 major peaks.


Part (b) - Touch Location Detection (10 points)

Loaded the touch data (HW3.Pr3.touch.txt) and repeated the correlation analysis. Then I compared the capacitance values to the no-touch baseline.

Capacitance Comparison:

Position  | No Touch | With Touch | Change
----------|----------|------------|----------
5 mm      | 39.34    | 34.90      | -4.44
10 mm     | 27.12    | 10.50      | -16.63  <-- biggest change
15 mm     | 33.71    | 25.09      | -8.62
20 mm     | 15.72    | 13.98      | -1.74
25 mm     | 7.17     | 8.10       | +0.93

The biggest capacitance change is at 10 mm, which makes sense since that's where the finger is touching.

Touch Location Estimation:
I fit a Gaussian curve to the capacitance differences (assuming the finger response is Gaussian in space as stated in the problem).

Result: Touch location = 10.86 mm

The Gaussian fit gives:
- Peak position: 10.86 mm
- Amplitude: -16.97 (negative because touch decreases capacitance)
- Width (sigma): 3.63 mm

So the finger is touching right around the 10mm sensor position, which matches the data showing the largest capacitance change at that location.

[See plot: problem2_touch_sensor.png - shows both the correlation peaks and the Gaussian fit]


Part (c) - Noise Estimation (10 points, extra credit)

To estimate the noise in each sample before correlation, I looked at the off-peak regions of the correlation output (far from the 5 main peaks).

Method:
- Excluded ±50 samples around each peak
- Calculated standard deviation of the remaining correlation values
- Accounted for the processing gain from correlation

Results:
- Standard deviation of off-peak correlation: 2.19
- Noise per sample (before correlation): 0.097

The correlation process gives us a processing gain of about √511 ≈ 22.6, which reduces the apparent noise by that factor. Working backwards, the noise in each original sample is around 0.097 (arbitrary units matching the signal scale).


================================================================================
PROBLEM 3: DFT/FFT EXERCISES
================================================================================

Part (a) - Relationship between Y(k) and H(ω) (10 points)

For a linear time-invariant system with frequency response H(ω) and periodic input x(n) with period N:

Y(k) = H(2πk/N) · X(k)

where:
- Y(k) is the N-point DFT of the output signal y(n)
- X(k) is the N-point DFT of the input signal x(n)
- H(ω) is the frequency response of the system

Explanation:
Since the input is periodic with period N, it only has frequency components at ω = 2πk/N for integer k. The DFT naturally samples at exactly these frequencies. Each frequency component gets multiplied by the system's frequency response at that frequency, which is just H(2πk/N).

Basically, the DFT output Y(k) is just the DFT input X(k) scaled by whatever the system's frequency response is at that specific frequency.


Part (b) - Minimum Sampling Requirements (10 points)

Given:
- Analog signal bandwidth B = 4 kHz
- Desired frequency resolution ≤ 50 Hz
- Need N = 2^m (power of 2) for FFT

Minimum sampling rate:
By Nyquist: fs ≥ 2B = 2(4000) = 8000 Hz

Answer: Minimum sampling rate = 8 kHz

Minimum record length:
Frequency resolution Δf = fs/N = 1/T
For Δf ≤ 50 Hz, we need: T ≥ 1/50 = 0.02 seconds

Answer: Minimum record length = 20 ms (0.02 seconds)

Minimum number of samples:
N = fs × T = 8000 × 0.02 = 160 samples

Since we need N = 2^m, round up to the next power of 2:
2^7 = 128 (too small)
2^8 = 256 (works!)

Answer: Minimum N = 256 samples (which is 2^8)

Summary:
- Sampling rate: 8 kHz
- Record length: 20 ms
- Number of samples: 256


Part (c) - Frequency Sampling and Time-Domain Aliasing (10 points)

Signal: x(n) = 0.8^|n| for -∞ < n < ∞

DTFT: X(ω) = (1 - 0.64) / (1 - 1.6cos(ω) + 0.64)

First, I plotted X(ω) for 0 ≤ ω ≤ 2π with a = 0.8.
[See plot: problem3c_dtft.png]

Then I sampled X(ω) at N discrete points (X(2πk/N) for k = 0, 1, ..., N-1) and computed the inverse FFT to get the time-domain signal.

Results for N = 20:
The reconstructed signal doesn't match x(n) = 0.8^|n| very well. The values at n=0 are close, but the signal shows weird artifacts and doesn't decay properly.

Results for N = 100:
Much better! Near n=0, the reconstructed signal matches x(n) = 0.8^|n| almost perfectly.

[See plot: problem3c_ifft_comparison.png]

What's happening when N=20?

TIME-DOMAIN ALIASING!

Here's what's going on:
The true signal x(n) = 0.8^|n| extends to infinity in both directions (it never quite reaches zero). When we sample the frequency domain at only N=20 points and take the IFFT, we're assuming the time-domain signal is PERIODIC with period 20.

For N=20:
- The signal tails at n > 10 wrap around and add to the signal at n < 0
- The signal tails at n < -10 wrap around and add to the signal at n > 0
- This "circular aliasing" messes up the reconstructed signal

For N=100:
- The period is 100 samples, much longer
- By the time we get to n = ±50, the signal x(n) = 0.8^|n| has decayed to almost nothing
- Very little wrapping occurs, so the reconstruction is accurate near n = 0

This is exactly like regular frequency aliasing (when you undersample in time), but happening in reverse - undersampling in frequency causes aliasing in time!

The key insight: When you sample in the frequency domain, you make the time-domain signal periodic. If the time signal doesn't naturally decay to zero within one period, you get aliasing.


================================================================================
CODE AND PLOTS
================================================================================

All work is in hw3_solution.py

Generated plots:
1. problem1b_autocorr_prbs511.png - Shows perfect spike at zero, -1 elsewhere
2. problem1b_autocorr_255bit.png - Shows the best 255-bit subsequence (still not a true PRBS255)
3. problem1c_crosscorr.png - Cross-correlation between the two PRBS511 generators
4. problem2_touch_sensor.png - Touch sensor correlation peaks and location fit
5. problem3c_dtft.png - Frequency domain plot of X(ω)
6. problem3c_ifft_comparison.png - Demonstrates time-domain aliasing (N=20 vs N=100)


================================================================================
KEY TAKEAWAYS
================================================================================

Problem 1: PRBS sequences have excellent autocorrelation properties (sharp peak, low sidelobes) which makes them useful for synchronization and spreading codes in communication systems.

Problem 2: CDMA using PRBS codes lets you transmit on multiple channels simultaneously. Correlation pulls out each channel's signal from the noisy mixture. Really cool application to touch sensing.

Problem 3: Sampling in frequency domain makes the time signal periodic (dual of Nyquist sampling theorem). If you don't sample enough frequency points, you get time-domain aliasing.
